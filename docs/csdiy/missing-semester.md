# Missing Semester

## shell

shell 是怎么知道命令要做什么？

自带内置程序，有搜索方法确定命令的位置

通过环境变量实现，事实上，shell，特别是bash，是一个编程语言，可以定义变量，函数，甚至是自定义命令

提示词后面不经能够运行带有参数的程序，也可以做while，for循环等等，这些是编写shell脚本需要干的

环境变量是在启动shell时设置的东西，不是每次运行必须设置的东西，很多都设置好了（例如，主目录，用户名）

查看搜索路径，就需要PATH环境变量

所有的路径列表，shell就是在这些路径中搜索程序的

```shell
echo $PATH
```

当你键入程序的名称时，bash会在计算机上搜索这个路径列表，并且在每个目录中查找，与你尝试运行的命令匹配的程序或者文件的名称

which命令可以查看命令的路径

```shell
which ls
```

路径：描述计算机上文件位置的方法，可以是绝对路径，也可以是相对路径。绝对路径是从根目录开始的，相对路径是相对于当前目录的

```shell
/usr/bin/ls
```

linux系统中，绝对路径是以/开头的，相对路径是以.或者..开头的

```shell
./ls
```

./表示当前目录，../表示上一级目录

windows系统中，绝对路径是以盘符开头的，相对路径是以.或者..开头的

```shell
C:\Windows\System32\cmd.exe
```

```shell
.\cmd.exe
```

window上，每一个盘符都有一个根目录，例如C盘的根目录是C:\

```shell
C:\Windows\System32\cmd.exe
```

```shell
D:\Documents\GitHub\missing-semester\docs\csdiy\missing-semester.md
```

在windows里每一个驱动器都有一个单独的路径结构

linux和macos都挂在一个盘符下，所以只有一个根目录

```shell
/usr/bin/ls
```

```shell
/Users/username/Documents/GitHub/missing-semester/docs/csdiy/missing-semester.md
```

在linux和macos上，每一个用户都有一个主目录，这个目录是/home/username或者/Users/username

找出当前位置，pwd命令

```shell
pwd
```

```shell
/Users/username/Documents/GitHub/missing-semester/docs/csdiy
```

.和..是特殊的目录，.表示当前目录，..表示上一级目录

ls: 列出目录中的文件

也可以给出参数，例如..

cd ~: 回到主目录.也可以用~写相对目录

cd -: 回到上一个目录

mkdir: 创建目录

大多数命令都有选项，选项是用来修改命令行为的，选项通常是一个短横线，后面跟一个字母

```shell
ls -l
```

最多的是-- help

```shell
ls --help
```

在打印出的信息中，有一些是选项，有一些是参数。usage中的[]表示可选参数，<>表示必选参数。...表示0,1,或者多个选项

flag: 选项，固定的
option: 选项，后面跟自己定义的东西

```shell
ls -l /home/username
```

给出更加详细的信息：文件的权限，文件的拥有者，文件的大小，文件的创建时间

```shell
ls -l /home/username/Documents
```

输出

```shell
total 0
drwxr-xr-x  2 username  staff   68B Dec 10 10:50 Documents
```

total 0: 0表示文件的大小，total表示文件的总大小

drwxr-xr-x: 第一个字符表示文件类型，d表示目录，-表示普通文件，l表示链接文件，b表示块设备文件，c表示字符设备文件，p表示管道文件，s表示socket文件

rwxr-xr-x: 后面9个字符表示拥有者的权限，第一个字符表示读权限，第二个字符表示写权限，第三个字符表示执行权限，后面8个字符表示组权限，后面8个字符表示其他用户的权限

这里可以看到拥有者是rwxr，如果这些被替换成了-，那就是没有权限

Dec 10 10:50: 表示文件创建的时间

如果有写入修改的权限，但是没有修改文件夹的权限，那也是不能修改整个文件的，只能清空文件内容

如果要操作文件（打开，读取，写入文件） 如果要cd进入文件夹，那么必须要该文件夹和所有根目录的权限

mv:重命名，需要两个路径，新路径和旧路径，所以可以一边改名字，一边改路径

cp 复制文件：两个路径：一个是旧文件的路径，另外一个是新路径

rm：删除文件，提供路径的地址

不能使用rm删除文佳佳，需要使用rm -r删除进行递归删除，删除路径下的所有内容

rmdir：只能删除空文件夹

mkdir 创建一个中间含有空格的目录：用“括起来"

如果想了解更多命令在平台上如何工作的信息，可以使用man命令

用于制作手册页

man 以另外一个程序的名称为参数，给出手册页

```shell
man ls
```

和ls --help类似，但是更加适合阅读

在底部我们可以找到实力，编写者信息等内容，最后可以用q来退出程序（之前没显示，现在会显示

CTRL+L是一个便捷的键盘快捷键，可以清除中断并且回到顶部（类似于win的cls）

### 组合程序

```shell
echo hello > hello.txt
```

在当前的文件夹创建hello.txt,然后软如hello

cat：打印文件内容

cat支持文件输入和输出

cat < hello.txt

打开hello.txt，设置为cat命令的输入，再输出打印

cat < hello.txt > hello2.txt

这样不会输出，应为输出被>接受到hello2.txt里了

如果是

cat < hello.txt >> hello2.txt

那就复制两次

管道符 |

把左边的输入当做右边的输出

tail：获取最后几行输出的信息

## shell

shell中一些命令已经非常好用，但是我们仍然可以通过组合这些命令来实现更加复杂的功能，或者把他变成一种编程语言

定义变量

```shell
name="John"
foo=bar
echo foo
>>>bar
```

在使用bash的时候，空格非常重要，定义变量的时候，=左右都不能有空格

使用纯文本的时候，可以使用单引号或者双引号

```shell
name='John'
foo="bar"
```

但是双引号的可以替换变量，单引号的不行。

我们可以用vim来编辑函数

```vim
function hello {
    echo "Arguments: $1"
    cd "$1"
}
```

$1表示第一个变量，$2表示第二个变量

vim 文件名称：打开文件

使用source命令来定义函数

```shell
source hello.sh
```

也可以直接运行

```shell

hello tset
```

`$`的用法：

1. `$1-$9`获取第1-9个变量
2. `$_`获得上一个命令的输出
3. `$?`获取上一个报错信息

## vim

首先，我们不能忘记基本的创建文件的方法

在Linux中，新建文件有多种方法。以下是一些常用的方法：

 1. 使用 `touch` 命令
`touch` 命令是最常见的用于创建空文件的方法。

```sh
touch filename
```

 2. 使用 `echo` 命令
使用 `echo` 命令可以将文本输出到新文件中。

```sh
echo "Some text" > filename
```

3. 使用 `cat` 命令
使用 `cat` 命令从标准输入中创建文件。

```sh
cat > filename
```

然后输入你想要的内容，完成后按 `Ctrl+D` 结束输入。

 4. 使用 `nano` 或其他文本编辑器
你可以使用任何文本编辑器创建并编辑文件。例如，使用 `nano`：

```sh
nano filename
```

 5. 使用 `> ` 操作符
你也可以使用重定向操作符 `>` 创建空文件。

```sh
> filename
```

以上这些方法都可以帮助你在Linux系统中创建新文件。选择适合你需求的方法即可。

其他的看笔记慢慢学吧，现在基本的还是会的，想要操作的话有想到不方便的地方继续搜一下

## 数据整理

`sudo journalctl`可以查看所有日志文件
`sudo journalctl |grep -i intel `可以查看所有包含intel的文件（用于查找）
数据整理需要明确哪些工具可以被用来达成特点数据整理的目的，并且明白如何使用这些工具。

日志处理事比较常见的信息

但是使用上面的数据处理的是时候，这个实际上是让计算机在shell里运行了整个`journalctl`程序之后，再对输出的程序进行整理，这样很浪费计算机资源

所以我们可以简化
`ssh 'jiurnal | grep ssh | grep "Disconnected from"'`,这样就先在服务端运行，然后再把我想要的行发给我就好了

然后也可以使用`|less`进行分页查看

grep对输出进行缓存，这一步往往会处理很多文件，看机器运行速度，但是如果把所有的文件都发回来再本地处理的话，那就看网速了(更加玄学）

`cat ssh.log`可以输出网络连接的日志

`less`可以做到滚动浏览，甚至可以使用vim来浏览（ctrl U ctrl D）
#### sed工具

`sed`是一个流处理器，来源于`ed`，允许我们修改流的内容

可以视为文本替换，实际上是运行在流上的一个完整的编程语言

用法 `sed 's/.*Disconnected from//'`
含义 sed进入工具，然后s表示替换， 这个时候又两个变量，都在/后，一个是表示搜索的字符串，另外一个表示替换的字符串

这里搜索的字符串表示为`Disconnected from`
替换的字符串则表示为空

这里还要用到正则表达式，进行数据处理

正则表达式实际上是一种非常强大的匹配文本，可以来匹配任何东西。

本质上是一串程序 
`.`表示任意的单个字符
`*`表示匹配0次或者多次该字符
`+`表示匹配一次或者多次该字符
`[]`匹配不同的字符，比如`sed 's/[ab]/'`把`a`或者`b`（第一个匹配的字符）替换成空字符

在正则表达式中，默认替换一次

如果在后面填上一个`/g`，比如`sed 's/[ab]//g'`，那就会把能替换的全部替换了

我们也可以添加其他修饰符

`sed `是一个很古老的工具，一般需要`sed -E`连接后面的语句
`^`
`$` 

遇到复杂的数据结构的时候，需要使用正则表达式匹配这些独特的数据，删除不需要的，保留需要的

任何`()`都是一个捕获组：指定我们关心的数值，并且反复使用。

先匹配整行，然后引用捕获组`\2`，也就是在替换中放入在第二个捕获组匹配到的值，也就是第二个`()`里的值。

正则调试器：可以去网上找找，会解释很多东西，还可以测试捕获组，确定整个捕获组都满足。

正常情况下正则表达式只会在本行内匹配，而不是跨行匹配

sed也是逐行操作，为每一行去匹配这个表达式

#### sort
接受多行输入，然后把排序好的行输出

`sort -n`数字排序
`sort -k`选中以空格为分隔符的列来执行排序，后面可以接`a,b`表示从第`a`列开始`b`列结束
（可以用来判断只看第几行来排序）
`tail -n10`选取最后10行
##### `unip`
查看一个排序后的行列表，去除那些重复的行。
`uniq -c`计算重复的次数
`wc -l`查看输出多少行
##### `awk`：一种基于列的流处理器
仍然提供文本处理，但是更加专注列数据。
按照空格来分开各个列

##### `paste`用来把多行变成单行

##### `bc`：简洁的命令行计算器

我们可以结合之前的数据处理方法，把多行的数据`paste -sd+`变成单行加在一起（当然，也可以其他运算）然后结尾一个`|bc -l`,得出所有总数

##### R：专门处理数据的语言

我认为的垃圾数据，混乱一堆没啥好看的，mit的老师还可以教我们组合，分析，整理，出图，震撼，真的震撼。

##### `xrag`把一系列列表转换为参数

## 命令行环境

